diff --git a/mppsolar/__init__.py b/mppsolar/__init__.py
index 85e02aa..870eb1f 100755
--- a/mppsolar/__init__.py
+++ b/mppsolar/__init__.py
@@ -277,10 +277,10 @@ def main():
         """Log detailed process information for debugging"""
         if log_func is None:
             log_func = print
-    
+
         pid = os.getpid()
         ppid = os.getppid()
-    
+
         # Get process group and session info
         try:
             pgid = os.getpgid(0)
@@ -288,12 +288,12 @@ def main():
         except:
             pgid = "unknown"
             sid = "unknown"
-    
+
         # Check if we're the process group leader
         is_leader = (pid == pgid)
-    
+
         log_func(f"[{label}] PID: {pid}, PPID: {ppid}, PGID: {pgid}, SID: {sid}, Leader: {is_leader}")
-    
+
         # Log command line that started this process
         try:
             with open(f'/proc/{pid}/cmdline', 'r') as f:
@@ -317,7 +317,6 @@ def main():
 
 
     def setup_daemon_if_requested(args, log_file_path="/var/log/mpp-solar.log"):
-
         if args.daemon:
             os.environ["MPP_SOLAR_DAEMON"] = "1"
             log.info("Daemon mode requested")
@@ -340,28 +339,35 @@ def main():
 
             daemon.keepalive = 60
 
-            log.info("Attempting traditional daemonization...")
-            try:
-#                 daemonize()
-                log.info("Daemonized successfully")
-                # Re-setup logging for the daemonized process
+            # Only call daemonize() for DISABLED daemon type (manual daemonization)
+            # OpenRC, systemd, and other init systems handle daemonization themselves
+            if daemon_type == DaemonType.DISABLED:
+                log.info("Using DISABLED daemon type - performing manual daemonization...")
+                try:
+                    daemonize()
+                    log.info("Daemonized successfully")
+                    # Re-setup logging for the daemonized process
+                    if not setup_daemon_logging(log_file_path):
+                        sys.stderr.write("CRITICAL: Failed to setup file logging for daemon. Check permissions.\n")
+                    else:
+                        log.info("Daemon file logging successfully re-initialized.")
+                except Exception as e:
+                    log.error(f"Failed to daemonize process: {e}")
+                    log.info("Continuing in foreground mode")
+            else:
+                log.info(f"Using {daemon_type.name} daemon type - init system will handle process management")
+                # For OpenRC/systemd, we still need to setup file logging since we're running as daemon
                 if not setup_daemon_logging(log_file_path):
-                    sys.stderr.write("CRITICAL: Failed to setup file logging for daemon. Check permissions.\n")
+                    log.warning("Failed to setup file logging for daemon. Check permissions.")
                 else:
-                    log.info("Daemon file logging successfully re-initialized.")
-
-            except Exception as e:
-                log.error(f"Failed to daemonize process: {e}")
-                log.info("Continuing in foreground mode")
+                    log.info("Daemon file logging setup successful.")
 
             return daemon
         else:
             log.info("Daemon mode NOT requested. Using DISABLED daemon.")
             daemon = get_daemon(daemontype=DaemonType.DISABLED)
-            log_process_info("DAEMON_DISABLED_CREATED", log.info)
             return daemon
 
-
     # --- Optional PyInstaller bootstrap cleanup ---
     # To enable single-process daemon spawn logic (avoids PyInstaller parent):
     #################################################################
diff --git a/mppsolar/daemon/daemon.py b/mppsolar/daemon/daemon.py
index e45cf20..9abfd42 100644
--- a/mppsolar/daemon/daemon.py
+++ b/mppsolar/daemon/daemon.py
@@ -38,19 +38,30 @@ def daemonize():
     """
     Properly daemonize the process (Unix double-fork)
     Enhanced for PyInstaller compatibility
+    This should ONLY be called when using DaemonType.DISABLED
     """
+    import sys
     import logging
-    from mppsolar.daemon.pyinstaller_runtime import is_pyinstaller_bundle, has_been_spawned
 
     log = logging.getLogger("daemon")
     pid = os.getpid()
     ppid = os.getppid()
     log.info(f"[DAEMONIZE] Before fork PID: {pid}, PPID: {ppid}")
 
+    # Import PyInstaller runtime functions safely
+    try:
+        from mppsolar.daemon.pyinstaller_runtime import is_pyinstaller_bundle, has_been_spawned
+    except ImportError:
+        # Fallback if module not available
+        def is_pyinstaller_bundle():
+            return getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS')
+        def has_been_spawned():
+            return os.environ.get("MPP_SOLAR_SPAWNED") == "1"
+
     # Special handling for PyInstaller spawned processes
     if is_pyinstaller_bundle() and has_been_spawned():
         log.info("[DAEMONIZE] Running in spawned PyInstaller process - using modified daemonization")
-        
+
         # We're already in a subprocess, so we can do a simpler daemonization
         # Just do a single fork and session setup
         try:
@@ -66,24 +77,16 @@ def daemonize():
         os.chdir("/")
         os.setsid()
         os.umask(0)
-        
+
         # Redirect standard file descriptors
-        sys.stdout.flush()
-        sys.stderr.flush()
-        try:
-            with open('/dev/null', 'r') as si: # Disable only while testing.
-                os.dup2(si.fileno(), sys.stdin.fileno())
-            with open('/dev/null', 'a+') as so:
-                os.dup2(so.fileno(), sys.stdout.fileno())
-            with open('/dev/null', 'a+') as se:
-                os.dup2(se.fileno(), sys.stderr.fileno())
-            log.info("[DAEMONIZE] Standard I/O redirected to /dev/null.") # This log won't appear on console
-        except Exception as e:
-            pass # Keep original pass here, as the log might not work yet
+        _redirect_std_descriptors()
         log.info(f"[DAEMONIZE] PyInstaller daemon process ready. PID: {os.getpid()}")
         return
 
     # Standard daemonization for non-PyInstaller or direct execution
+    log.info("[DAEMONIZE] Performing standard double-fork daemonization")
+
+    # First fork
     try:
         pid = os.fork()
         if pid > 0:
@@ -93,10 +96,12 @@ def daemonize():
         log.error(f"First fork failed: {e}")
         sys.exit(1)
 
+    # Decouple from parent environment
     os.chdir("/")
     os.setsid()
     os.umask(0)
 
+    # Second fork
     try:
         pid = os.fork()
         if pid > 0:
@@ -106,18 +111,29 @@ def daemonize():
         log.error(f"Second fork failed: {e}")
         sys.exit(1)
 
-    # Redirect standard file descriptors to /dev/null
+    # Redirect standard file descriptors
+    _redirect_std_descriptors()
+    log.info(f"[DAEMONIZE] Daemon process forked successfully. PID: {os.getpid()}")
+
+
+def _redirect_std_descriptors():
+    """Helper function to redirect standard file descriptors to /dev/null"""
+    import sys
+
     sys.stdout.flush()
     sys.stderr.flush()
-    with open('/dev/null', 'r') as si:  # Disabled while testing pyinstaller code
-        os.dup2(si.fileno(), sys.stdin.fileno())
-    with open('/dev/null', 'a+') as so:
-        os.dup2(so.fileno(), sys.stdout.fileno())
-    with open('/dev/null', 'a+') as se:
-        os.dup2(se.fileno(), sys.stderr.fileno())
-
-    log.info(f"[DAEMONIZE] Daemon process forked successfully. PID: {os.getpid()}")
 
+    try:
+        with open('/dev/null', 'r') as si:
+            os.dup2(si.fileno(), sys.stdin.fileno())
+        with open('/dev/null', 'a+') as so:
+            os.dup2(so.fileno(), sys.stdout.fileno())
+        with open('/dev/null', 'a+') as se:
+            os.dup2(se.fileno(), sys.stderr.fileno())
+    except Exception as e:
+        # If redirection fails, log the error but continue
+        # (logging might not work after redirection anyway)
+        pass
 
 
 class Daemon:
