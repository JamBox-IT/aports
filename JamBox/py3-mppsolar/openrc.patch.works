diff --git a/mppsolar/__init__.py b/mppsolar/__init__.py
index d77a1c6..f26b70a 100755
--- a/mppsolar/__init__.py
+++ b/mppsolar/__init__.py
@@ -7,7 +7,7 @@ from platform import python_version
 from mppsolar.version import __version__  # noqa: F401
 
 from mppsolar.helpers import get_device_class
-from mppsolar.daemon import get_daemon
+from mppsolar.daemon import get_daemon, detect_daemon_type
 from mppsolar.daemon import DaemonType
 from mppsolar.libs.mqttbrokerc import MqttBroker
 from mppsolar.outputs import get_outputs, list_outputs
@@ -192,6 +192,16 @@ def main():
         action="store_true",
         help="Enable Debug and above (i.e. all) messages",
     )
+    parser.add_argument(
+        "--pidfile",
+        help="Specifies the PID file location for daemon mode (default: /var/run/mpp-solar.pid, /tmp/mpp-solar.pid for PyInstaller)",
+        default=None,
+    )
+    parser.add_argument(
+        "--daemon-stop", 
+        action="store_true", 
+        help="Stop a running daemon (requires --pidfile if using non-default location)"
+    )
     parser.add_argument("-I", "--info", action="store_true", help="Enable Info and above level messages")
 
     args = parser.parse_args()
@@ -234,6 +244,91 @@ def main():
         #    print(result)
         return None
 
+    def setup_daemon_mode(args):
+        """Setup daemon mode with proper error handling and configurable PID file"""
+        import sys
+        import os
+    
+        # Check if we're running as PyInstaller bundle
+        is_pyinstaller = getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS')
+    
+        # Handle daemon stop request
+        if args.daemon_stop:
+            pid_file_path = args.pidfile
+            if pid_file_path is None:
+                # Use default based on environment
+                if is_pyinstaller or os.geteuid() != 0:  # Non-root or PyInstaller
+                    pid_file_path = "/tmp/mpp-solar.pid"
+                else:
+                    pid_file_path = "/var/run/mpp-solar.pid"
+        
+            log.info(f"Attempting to stop daemon using PID file: {pid_file_path}")
+        
+            try:
+                daemon_type = detect_daemon_type()
+                daemon_class = get_daemon(daemontype=daemon_type).__class__
+                if hasattr(daemon_class, 'stop_daemon'):
+                    success = daemon_class.stop_daemon(pid_file_path)
+                    if success:
+                        print("Daemon stopped successfully")
+                    else:
+                        print("Failed to stop daemon")
+                    sys.exit(0 if success else 1)
+                else:
+                    print("Daemon stop functionality not available for this daemon type")
+                    sys.exit(1)
+            except Exception as e:
+                print(f"Error stopping daemon: {e}")
+                sys.exit(1)
+    
+        if args.daemon:
+            log.info("Setting up daemon mode...")
+        
+            # Setup daemon logging first
+            if not setup_daemon_logging("/var/log/mpp-solar.log"):
+                log.warning("Failed to setup file logging, continuing with console logging")
+        
+            # For PyInstaller bundles, skip traditional daemonization
+            if is_pyinstaller:
+                log.info("Running as PyInstaller bundle - skipping process daemonization")
+            else:
+                log.info("Attempting traditional daemonization...")
+                try:
+                    daemonize()
+                    log.info("Process daemonized successfully")
+                except Exception as e:
+                    log.error(f"Failed to daemonize process: {e}")
+                    log.info("Continuing without daemonization...")
+    
+        # Initialize Daemon handler
+        if not args.daemon:
+            daemon = get_daemon(daemontype=DaemonType.DISABLED)
+        else:
+            try:
+                daemon_type = detect_daemon_type()
+                daemon = get_daemon(daemontype=daemon_type)
+            except Exception as e:
+                log.warning(f"Failed to detect daemon type: {e}, falling back to OpenRC")
+                daemon = get_daemon(daemontype=DaemonType.OPENRC)
+        
+            # Set custom PID file path if provided
+            if hasattr(daemon, 'pid_file_path'):
+                if args.pidfile:
+                    daemon.pid_file_path = args.pidfile
+                    log.info(f"Using custom PID file: {daemon.pid_file_path}")
+                else:
+                    # Determine default PID file location
+                    if is_pyinstaller or os.geteuid() != 0:  # Non-root or PyInstaller
+                        daemon.pid_file_path = "/tmp/mpp-solar.pid"
+                        log.info(f"Using default PID file for non-root/PyInstaller: {daemon.pid_file_path}")
+                    else:
+                        daemon.pid_file_path = "/var/run/mpp-solar.pid"
+                        log.info(f"Using default PID file for root: {daemon.pid_file_path}")
+        
+            daemon.keepalive = 60
+    
+        return daemon
+
     # mqttbroker:
     #     name: null
     #     port: 1883
@@ -270,7 +365,14 @@ def main():
     if not args.daemon:
         daemon = get_daemon(daemontype=DaemonType.DISABLED)
     else:
-        daemon = get_daemon(daemontype=DaemonType.SYSTEMD)
+#        daemon = get_daemon(daemontype=DaemonType.SYSTEMD)
+#        daemon.keepalive = 60
+        try:
+            daemon_type = detect_daemon_type()
+            daemon = get_daemon(daemontype=daemon_type)
+        except Exception as e:
+            log.warning(f"Failed to detect daemon type: {e}, falling back to OpenRC")
+            daemon = get_daemon(daemontype=DaemonType.OPENRC)
         daemon.keepalive = 60
     log.info(daemon)
 
diff --git a/mppsolar/daemon/__init__.py b/mppsolar/daemon/__init__.py
index d8eed7f..b8b2d9e 100644
--- a/mppsolar/daemon/__init__.py
+++ b/mppsolar/daemon/__init__.py
@@ -1,9 +1,10 @@
-from enum import Enum, auto
+from enum import Enum
 
 class DaemonType(Enum):
     """ Daemon types implemented """
     DISABLED = "disabled"
     SYSTEMD = "systemd"
+    OPENRC = "openrc"
 
 def get_daemon(daemontype):
     match daemontype:
@@ -13,5 +14,24 @@ def get_daemon(daemontype):
         case DaemonType.SYSTEMD:
             from .daemon_systemd import DaemonSystemd as daemon
             return daemon()
+        case DaemonType.OPENRC:
+            from .daemon_openrc import DaemonOpenRC as daemon
+            return daemon()
         case _:
-            raise Exception(f"unknown daemontype {daemontype}")
\ No newline at end of file
+            raise Exception(f"unknown daemontype {daemontype}")
+
+def detect_daemon_type():
+    """ Auto-detect the appropriate daemon type for the system """
+    import os
+    import shutil
+    
+    # Check if systemd is available
+    if shutil.which('systemctl') and os.path.exists('/run/systemd/system'):
+        return DaemonType.SYSTEMD
+    
+    # Check if OpenRC is available
+    if shutil.which('rc-service') or os.path.exists('/sbin/openrc'):
+        return DaemonType.OPENRC
+    
+    # Default to disabled/generic daemon
+    return DaemonType.OPENRC  # Use OpenRC implementation as fallback since it handles signals
diff --git a/mppsolar/daemon/daemon_openrc.py b/mppsolar/daemon/daemon_openrc.py
new file mode 100644
index 0000000..95ac8a3
--- /dev/null
+++ b/mppsolar/daemon/daemon_openrc.py
@@ -0,0 +1,360 @@
+""" daemon_openrc.py """
+import logging
+import os
+import signal
+import sys
+import time
+import atexit
+from enum import Enum
+from pathlib import Path
+
+try:
+    import psutil
+    HAS_PSUTIL = True
+except ImportError:
+    HAS_PSUTIL = False
+
+from mppsolar.daemon.daemon import Daemon
+
+# Set-up logger
+log = logging.getLogger("daemon_openrc")
+
+
+class OpenRCNotification(Enum):
+    READY = "READY"
+    STATUS = "STATUS"
+    STOPPING = "STOPPING"
+    WATCHDOG = "WATCHDOG"
+
+class DaemonOpenRC(Daemon):
+    """ OpenRC daemon implementation with signal handling and configurable PID management """
+    
+    def __str__(self):
+        return f"Daemon OpenRC (PID file: {self.pid_file_path})"
+    
+    def __init__(self, pid_file_path=None):
+        self._notify = self._openrc_notify
+        self._journal = self._openrc_journal
+        self._Notification = OpenRCNotification
+        self.keepalive = 60
+        self._lastNotify = time.time()
+        self._pid_file = None
+        self._running = True
+        
+        # Set PID file location with smart defaults
+        if pid_file_path:
+            self.pid_file_path = pid_file_path
+        else:
+            # Auto-determine based on permissions and environment
+            if os.geteuid() == 0:  # Running as root
+                self.pid_file_path = "/var/run/mpp-solar.pid"
+            else:  # Non-root user
+                # Try user-specific locations
+                if 'XDG_RUNTIME_DIR' in os.environ:
+                    self.pid_file_path = os.path.join(os.environ['XDG_RUNTIME_DIR'], "mpp-solar.pid")
+                else:
+                    self.pid_file_path = "/tmp/mpp-solar.pid"
+        
+        log.info(f"PID file will be created at: {self.pid_file_path}")
+        
+        # Register cleanup function to run on exit
+        atexit.register(self._cleanup_pid_file)
+        
+        # Set up signal handlers
+        signal.signal(signal.SIGTERM, self._signal_handler)
+        signal.signal(signal.SIGINT, self._signal_handler)
+        
+        # Optional: Handle SIGHUP for config reload
+        signal.signal(signal.SIGHUP, self._sighup_handler)
+    
+    def set_pid_file_path(self, path):
+        """Allow external setting of PID file path"""
+        old_path = self.pid_file_path
+        self.pid_file_path = path
+        log.info(f"PID file path changed from {old_path} to {self.pid_file_path}")
+    
+    def _signal_handler(self, signum, frame):
+        """ Handle SIGTERM and SIGINT for clean shutdown """
+        log.info(f"Received signal {signum}, initiating clean shutdown...")
+        self._running = False
+        self.stop()
+        self._cleanup_pid_file()
+        sys.exit(0)
+    
+    def _sighup_handler(self, signum, frame):
+        """ Handle SIGHUP for potential config reload """
+        log.info("Received SIGHUP - config reload not implemented yet")
+        # Future: implement config reload functionality
+    
+    def _create_pid_file(self):
+        """ Create PID file with current process ID """
+        pid = os.getpid()
+        log.info(f"Creating PID file {self.pid_file_path} with PID {pid}")
+        
+        try:
+            # Ensure directory exists and is writable
+            pid_dir = Path(self.pid_file_path).parent
+            pid_dir.mkdir(parents=True, exist_ok=True)
+            log.debug(f"PID directory ensured: {pid_dir}")
+            
+            # Check directory permissions
+            if not os.access(pid_dir, os.W_OK):
+                log.error(f"No write permission for PID directory: {pid_dir}")
+                return False
+            
+            # Check if file already exists and handle appropriately
+            if os.path.exists(self.pid_file_path):
+                log.warning(f"PID file {self.pid_file_path} already exists, checking if daemon is running...")
+                if self._check_existing_daemon():
+                    log.error("Another daemon instance is already running")
+                    return False
+                else:
+                    log.info("Removing stale PID file")
+                    try:
+                        os.remove(self.pid_file_path)
+                    except Exception as e:
+                        log.error(f"Failed to remove stale PID file: {e}")
+                        return False
+            
+            # Create PID file with explicit write and flush
+            try:
+                # Use atomic write operation where possible
+                temp_pid_file = f"{self.pid_file_path}.tmp"
+                
+                with open(temp_pid_file, 'w') as pid_file:
+                    pid_file.write(str(pid))
+                    pid_file.flush()  # Ensure data is written to disk
+                    os.fsync(pid_file.fileno())  # Force kernel to write to disk
+                
+                # Atomically move temp file to final location
+                os.rename(temp_pid_file, self.pid_file_path)
+                
+                log.info(f"Successfully created PID file: {self.pid_file_path} with PID {pid}")
+                
+                # Verify the file was written correctly
+                with open(self.pid_file_path, 'r') as verify_file:
+                    written_pid = verify_file.read().strip()
+                    if written_pid != str(pid):
+                        log.error(f"PID file verification failed: expected {pid}, got '{written_pid}'")
+                        return False
+                    log.debug(f"PID file verification successful: {written_pid}")
+                
+                return True
+                
+            except Exception as e:
+                log.error(f"Failed to write to PID file {self.pid_file_path}: {e}")
+                # Clean up temporary file if it exists
+                temp_pid_file = f"{self.pid_file_path}.tmp"
+                if os.path.exists(temp_pid_file):
+                    try:
+                        os.remove(temp_pid_file)
+                    except:
+                        pass
+                return False
+                
+        except Exception as e:
+            log.error(f"Failed to create PID file {self.pid_file_path}: {e}")
+            return False
+    
+    def _cleanup_pid_file(self):
+        """ Remove PID file on shutdown """
+        try:
+            if os.path.exists(self.pid_file_path):
+                # Verify it's our PID before removing
+                try:
+                    with open(self.pid_file_path, 'r') as pid_file:
+                        content = pid_file.read().strip()
+                        if content and int(content) == os.getpid():
+                            os.remove(self.pid_file_path)
+                            log.info(f"Removed PID file: {self.pid_file_path}")
+                        else:
+                            log.warning(f"PID file contains different PID ({content}), not removing")
+                except ValueError:
+                    log.warning(f"PID file contains invalid data, removing anyway")
+                    os.remove(self.pid_file_path)
+        except Exception as e:
+            log.error(f"Failed to remove PID file {self.pid_file_path}: {e}")
+    
+    def _check_existing_daemon(self):
+        """ Check if daemon is already running """
+        if not os.path.exists(self.pid_file_path):
+            return False
+        
+        try:
+            with open(self.pid_file_path, 'r') as pid_file:
+                content = pid_file.read().strip()
+                if not content:
+                    log.warning(f"Empty PID file found: {self.pid_file_path}")
+                    return False
+                
+                pid = int(content)
+                log.debug(f"Found PID {pid} in PID file")
+            
+            if HAS_PSUTIL:
+                # Use psutil to check if process exists and is our daemon
+                try:
+                    process = psutil.Process(pid)
+                    if process.is_running():
+                        # Additional check: verify it's actually our process
+                        cmdline = ' '.join(process.cmdline())
+                        if 'mpp-solar' in cmdline or 'mppsolar' in cmdline:
+                            log.warning(f"Daemon already running with PID {pid}")
+                            return True
+                        else:
+                            log.info(f"PID {pid} exists but is not our daemon process")
+                            return False
+                except psutil.NoSuchProcess:
+                    log.info(f"Stale PID file found (process {pid} doesn't exist), removing: {self.pid_file_path}")
+                    try:
+                        os.remove(self.pid_file_path)
+                    except:
+                        pass
+                    return False
+            else:
+                # Fallback: check if PID exists in /proc (Linux-specific)
+                if os.path.exists(f"/proc/{pid}"):
+                    log.warning(f"Daemon may already be running with PID {pid}")
+                    return True
+                else:
+                    log.info(f"Stale PID file found (no /proc/{pid}), removing: {self.pid_file_path}")
+                    try:
+                        os.remove(self.pid_file_path)
+                    except:
+                        pass
+                    return False
+                    
+        except (ValueError, FileNotFoundError) as e:
+            log.error(f"Invalid PID file {self.pid_file_path}: {e}")
+            # Remove invalid PID file
+            try:
+                os.remove(self.pid_file_path)
+                log.info("Removed invalid PID file")
+            except:
+                pass
+            return False
+        
+        return False
+    
+    def initialize(self):
+        """ Initialize daemon - create PID file and set up """
+        log.info("Initializing OpenRC daemon...")
+        log.info(f"Current process PID: {os.getpid()}")
+        log.info(f"PID file location: {self.pid_file_path}")
+        
+        # Create PID file
+        if not self._create_pid_file():
+            log.error("Failed to create PID file. Exiting.")
+            sys.exit(1)
+        
+        # Call parent initialization
+        super().initialize()
+        log.info("OpenRC daemon initialized successfully")
+    
+    def _openrc_notify(self, notification, message=None):
+        """ Internal notification method """
+        if message:
+            log.info(f"Daemon notification: {notification} - {message}")
+        else:
+            log.info(f"Daemon notification: {notification}")
+    
+    def _openrc_journal(self, message):
+        """ Internal journal method - just log """
+        log.info(f"Daemon journal: {message}")
+    
+    def watchdog(self):
+        """ Watchdog function - just log activity """
+        elapsed = time.time() - self._lastNotify
+        if elapsed > self.keepalive:
+            self._lastNotify = time.time()
+            log.debug(f"Daemon watchdog at {self._lastNotify}")
+    
+    def notify(self, status="OK"):
+        """ Send notification - just log for OpenRC """
+        log.info(f"Daemon status: {status}")
+    
+    def stop(self):
+        """ Stop daemon gracefully """
+        log.info("Stopping OpenRC daemon...")
+        self._running = False
+    
+    def is_running(self):
+        """ Check if daemon should continue running """
+        return self._running
+    
+    @staticmethod
+    def stop_daemon(pid_file_path):
+        """ Static method to stop a running daemon """
+        if not os.path.exists(pid_file_path):
+            print(f"PID file {pid_file_path} not found - daemon may not be running")
+            return False
+        
+        try:
+            with open(pid_file_path, 'r') as pid_file:
+                content = pid_file.read().strip()
+                if not content:
+                    print(f"Empty PID file found: {pid_file_path}")
+                    os.remove(pid_file_path)
+                    return False
+                
+                pid = int(content)
+            
+            print(f"Stopping daemon with PID {pid}")
+            
+            # Send SIGTERM first
+            try:
+                os.kill(pid, signal.SIGTERM)
+            except ProcessLookupError:
+                print("Process not found - daemon may have already stopped")
+                # Clean up PID file
+                try:
+                    os.remove(pid_file_path)
+                    print(f"Removed stale PID file: {pid_file_path}")
+                except:
+                    pass
+                return True
+            
+            if HAS_PSUTIL:
+                try:
+                    process = psutil.Process(pid)
+                    # Wait up to 10 seconds for graceful shutdown
+                    process.wait(timeout=10)
+                    print("Daemon stopped gracefully")
+                except psutil.TimeoutExpired:
+                    print("Daemon didn't stop gracefully, sending SIGKILL")
+                    try:
+                        process.kill()
+                        print("Sent SIGKILL to daemon")
+                    except psutil.NoSuchProcess:
+                        print("Process already gone")
+                except psutil.NoSuchProcess:
+                    print("Daemon already stopped")
+            else:
+                # Fallback: just send SIGKILL after a delay
+                time.sleep(2)
+                try:
+                    os.kill(pid, signal.SIGKILL)
+                    print("Sent SIGKILL to daemon")
+                except ProcessLookupError:
+                    print("Daemon already stopped")
+            
+            # Clean up PID file
+            if os.path.exists(pid_file_path):
+                os.remove(pid_file_path)
+                print(f"Removed PID file: {pid_file_path}")
+            
+            return True
+            
+        except (ValueError, FileNotFoundError, ProcessLookupError) as e:
+            print(f"Error stopping daemon: {e}")
+            return False
+    
+    def _notify(self, notification, message=None):
+        """ Internal notification method """
+        if message:
+            log.info(f"Daemon notification: {notification.name} - {message}")
+        else:
+            log.info(f"Daemon notification: {notification.name}")
+    
+    def _journal(self, message):
+        """ Internal journal method - just log """
+        log.info(f"Daemon journal: {message}")
\ No newline at end of file
diff --git a/mppsolar/daemon_cli.py b/mppsolar/daemon_cli.py
new file mode 100644
index 0000000..dc27457
--- /dev/null
+++ b/mppsolar/daemon_cli.py
@@ -0,0 +1,166 @@
+#!/usr/bin/env python3
+""" Optional daemon_cli.py - CLI utility for managing mpp-solar daemon """
+
+import argparse
+import os
+import sys
+from pathlib import Path
+
+# Add the parent directory to sys.path to import mppsolar modules
+sys.path.insert(0, str(Path(__file__).parent.parent))
+
+from mppsolar.daemon import DaemonType, get_daemon, detect_daemon_type
+from mppsolar.daemon.daemon_openrc import DaemonOpenRC
+
+def start_daemon(args):
+    """ Start the daemon """
+    print("Starting mpp-solar daemon...")
+    
+    # Determine daemon type
+    if args.daemon_type:
+        daemon_type = DaemonType(args.daemon_type)
+    else:
+        daemon_type = detect_daemon_type()
+    
+    print(f"Using daemon type: {daemon_type.value}")
+    
+    # If OpenRC and fork requested, fork the process
+    if daemon_type == DaemonType.OPENRC and args.fork:
+        pid = os.fork()
+        if pid > 0:
+            print(f"Daemon forked with PID {pid}")
+            sys.exit(0)
+        # Child process continues
+    
+    # Import and run main with daemon flag
+    from mppsolar import main as mpp_main
+    
+    # Modify sys.argv to include daemon flag and config
+    original_argv = sys.argv.copy()
+    sys.argv = ['mpp-solar', '--daemon']
+    
+    if args.config:
+        sys.argv.extend(['-C', args.config])
+    
+    # Add any additional arguments
+    if args.debug:
+        sys.argv.append('--debug')
+    elif args.info:
+        sys.argv.append('--info')
+    
+    try:
+        mpp_main()
+    except KeyboardInterrupt:
+        print("\nDaemon stopped by user")
+    except Exception as e:
+        print(f"Daemon error: {e}")
+        sys.exit(1)
+    finally:
+        sys.argv = original_argv
+
+def stop_daemon(args):
+    """ Stop the daemon """
+    print("Stopping mpp-solar daemon...")
+    
+    pid_file = args.pid_file or "/var/run/mpp-solar.pid"
+    
+    if DaemonOpenRC.stop_daemon(pid_file):
+        print("Daemon stopped successfully")
+    else:
+        print("Failed to stop daemon")
+        sys.exit(1)
+
+def status_daemon(args):
+    """ Check daemon status """
+    pid_file = args.pid_file or "/var/run/mpp-solar.pid"
+    
+    if not os.path.exists(pid_file):
+        print("Daemon is not running (no PID file found)")
+        return
+    
+    try:
+        with open(pid_file, 'r') as f:
+            pid = int(f.read().strip())
+        
+        # Check if process exists
+        try:
+            import psutil
+            process = psutil.Process(pid)
+            if process.is_running():
+                print(f"Daemon is running with PID {pid}")
+                print(f"Command: {' '.join(process.cmdline())}")
+                print(f"Started: {process.create_time()}")
+            else:
+                print(f"PID file exists but process {pid} is not running")
+        except ImportError:
+            # Fallback without psutil
+            if os.path.exists(f"/proc/{pid}"):
+                print(f"Daemon appears to be running with PID {pid}")
+            else:
+                print(f"PID file exists but process {pid} is not running")
+                
+    except (ValueError, FileNotFoundError) as e:
+        print(f"Invalid PID file: {e}")
+
+def main():
+    parser = argparse.ArgumentParser(description="mpp-solar daemon management utility")
+    subparsers = parser.add_subparsers(dest='command', help='Available commands')
+    
+    # Start command
+    start_parser = subparsers.add_parser('start', help='Start the daemon')
+    start_parser.add_argument('--fork', action='store_true', 
+                             help='Fork the process (for OpenRC daemon)')
+    start_parser.add_argument('--daemon-type', choices=['disabled', 'systemd', 'openrc'],
+                             help='Force specific daemon type')
+    start_parser.add_argument('-C', '--config', 
+                             help='Configuration file path')
+    start_parser.add_argument('--debug', action='store_true',
+                             help='Enable debug logging')
+    start_parser.add_argument('--info', action='store_true',
+                             help='Enable info logging')
+    
+    # Stop command
+    stop_parser = subparsers.add_parser('stop', help='Stop the daemon')
+    stop_parser.add_argument('--pid-file', 
+                           help='PID file path (default: /var/run/mpp-solar.pid)')
+    
+    # Status command
+    status_parser = subparsers.add_parser('status', help='Check daemon status')
+    status_parser.add_argument('--pid-file',
+                              help='PID file path (default: /var/run/mpp-solar.pid)')
+    
+    # Restart command
+    restart_parser = subparsers.add_parser('restart', help='Restart the daemon')
+    restart_parser.add_argument('--fork', action='store_true',
+                               help='Fork the process (for OpenRC daemon)')
+    restart_parser.add_argument('--daemon-type', choices=['disabled', 'systemd', 'openrc'],
+                               help='Force specific daemon type')
+    restart_parser.add_argument('-C', '--config',
+                               help='Configuration file path')
+    restart_parser.add_argument('--pid-file',
+                               help='PID file path (default: /var/run/mpp-solar.pid)')
+    restart_parser.add_argument('--debug', action='store_true',
+                               help='Enable debug logging')
+    restart_parser.add_argument('--info', action='store_true',
+                               help='Enable info logging')
+    
+    args = parser.parse_args()
+    
+    if args.command == 'start':
+        start_daemon(args)
+    elif args.command == 'stop':
+        stop_daemon(args)
+    elif args.command == 'status':
+        status_daemon(args)
+    elif args.command == 'restart':
+        print("Restarting daemon...")
+        stop_daemon(args)
+        import time
+        time.sleep(2)  # Brief pause between stop and start
+        start_daemon(args)
+    else:
+        parser.print_help()
+
+if __name__ == '__main__':
+    main()
+
diff --git a/mppsolar/helpers.py b/mppsolar/helpers.py
index 70a608a..02e7e14 100644
--- a/mppsolar/helpers.py
+++ b/mppsolar/helpers.py
@@ -1,4 +1,6 @@
 #!/usr/bin/env python3
+import os
+import sys
 import logging
 import importlib
 
@@ -127,3 +129,78 @@ class CRC_XModem:
     def crc_hex(self, data):
         crc = self.compute_crc(data)
         return format(crc, '04x').upper()
+
+def daemonize():
+    """
+    Properly daemonize the process (Unix double-fork)
+    NOTE: This might not work well with PyInstaller executables
+    """
+    try:
+        # First fork
+        pid = os.fork()
+        if pid > 0:
+            # Parent process exits
+            sys.exit(0)
+    except OSError as e:
+        log.error(f"First fork failed: {e}")
+        sys.exit(1)
+    
+    # Decouple from parent environment
+    os.chdir("/")
+    os.setsid()
+    os.umask(0)
+    
+    try:
+        # Second fork
+        pid = os.fork()
+        if pid > 0:
+            # Second parent exits
+            sys.exit(0)
+    except OSError as e:
+        log.error(f"Second fork failed: {e}")
+        sys.exit(1)
+    
+    # Redirect standard file descriptors
+    sys.stdout.flush()
+    sys.stderr.flush()
+    
+    # Close stdin, stdout, stderr
+    with open('/dev/null', 'r') as si:
+        os.dup2(si.fileno(), sys.stdin.fileno())
+    
+    with open('/dev/null', 'w') as so:
+        os.dup2(so.fileno(), sys.stdout.fileno())
+    
+    with open('/dev/null', 'w') as se:
+        os.dup2(se.fileno(), sys.stderr.fileno())
+
+def is_pyinstaller_bundle():
+    """Check if running as PyInstaller bundle"""
+    return getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS')
+
+def setup_daemon_logging(log_file="/var/log/mpp-solar.log"):
+    """Setup logging for daemon mode"""
+    try:
+        # Create log directory if it doesn't exist
+        log_dir = os.path.dirname(log_file)
+        os.makedirs(log_dir, exist_ok=True)
+
+        # Setup file logging
+        file_handler = logging.FileHandler(log_file)
+        file_handler.setLevel(logging.INFO)
+
+        # Setup formatter
+        formatter = logging.Formatter(
+            '%(asctime)s:%(levelname)s:%(module)s:%(funcName)s@%(lineno)d: %(message)s'
+        )
+        file_handler.setFormatter(formatter)
+
+        # Get root logger and add handler
+        root_logger = logging.getLogger()
+        root_logger.addHandler(file_handler)
+
+        return True
+    except Exception as e:
+        print(f"Failed to setup daemon logging: {e}")
+        return False
+
diff --git a/mppsolar/main.py b/mppsolar/main.py
index 57a0ea0..8e51513 100644
--- a/mppsolar/main.py
+++ b/mppsolar/main.py
@@ -2,4 +2,6 @@ from mppsolar import main
 
 
 if __name__ == "__main__":
-    main()
+    main():
+        daemon = setup_daemon_mode(args)
+        log.info(daemon)
