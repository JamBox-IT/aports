name: Build and Release

on:
  push:
    branches:
      - main
      - 'v*'  # Match v3.19, v3.20, etc. (Alpine standard)
      - workflow-improvements  # Temporary for testing
    # Only trigger on actual package changes
    paths:
      - 'JamBox/*/APKBUILD'
      - 'testing/*/APKBUILD'
      - 'JamBox/**/*.patch'
      - 'testing/**/*.patch'
      - '.github/workflows/build-and-release.yml'
  workflow_dispatch:  # Allow manual triggering from GitHub Actions UI
    inputs:
      force_rebuild:
        description: 'Force rebuild all packages (ignores change detection)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  packages: write

env:
  ABUILD_ARCH: x86_64
  ABUILD_JOBS: $(nproc)

jobs:
  detect-changes:
    name: Detect Changed Packages
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.detect.outputs.packages }}
      has-changes: ${{ steps.detect.outputs.has-changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed packages
        id: detect
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"
          else
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          fi

          # Handle first commit case
          if [ "$BASE_SHA" = "0000000000000000000000000000000000000000" ] || [ -z "$BASE_SHA" ]; then
            CHANGED_FILES=$(find . -name APKBUILD -path './JamBox/*' -o -name APKBUILD -path './testing/*')
          else
            CHANGED_FILES=$(git diff --name-only $BASE_SHA..$HEAD_SHA | grep -E 'APKBUILD$|\.patch$' || true)
          fi

          if [ -z "$CHANGED_FILES" ]; then
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "packages=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract package directories
          PACKAGES=$(echo "$CHANGED_FILES" | sed 's|/APKBUILD||g; s|/.*\.patch||g' | sort -u | jq -R -s -c 'split("\n")[:-1]')
          echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
          echo "has-changes=true" >> $GITHUB_OUTPUT
          echo "Changed packages: $PACKAGES"

  filter-existing:
    name: Filter Already-Built Packages
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.filter.outputs.packages }}
      has-new: ${{ steps.filter.outputs.has-new }}
      skipped-existing: ${{ steps.filter.outputs.skipped-existing }}
    steps:
      - uses: actions/checkout@v4

      - name: Filter packages that already have releases
        id: filter
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PACKAGES='${{ needs.detect-changes.outputs.packages }}'
          ALPINE_VERSION="${{ github.ref == 'refs/heads/main' && 'edge' || github.ref_name }}"
          NEW_PACKAGES=()
          SKIPPED_EXISTING=()

          echo "Checking which packages already have releases..."

          for pkg_dir in $(echo "$PACKAGES" | jq -r '.[]'); do
            if [ ! -f "$pkg_dir/APKBUILD" ]; then
              echo "âš ï¸  No APKBUILD in $pkg_dir, skipping"
              continue
            fi

            # Source APKBUILD to get version info
            cd "$pkg_dir"
            . ./APKBUILD
            cd - > /dev/null

            # Construct the release tag that would be created
            release_tag="${pkgname}-${pkgver}-r${pkgrel}_alpine${ALPINE_VERSION}"

            # Check if this release already exists
            if gh release view "$release_tag" --repo "${{ github.repository }}" &>/dev/null; then
              echo "â­ï¸  SKIP: $pkgname - release $release_tag already exists"
              SKIPPED_EXISTING+=("$pkgname")
            else
              echo "ðŸ†• BUILD: $pkgname - no release found for $release_tag"
              NEW_PACKAGES+=("$pkg_dir")
            fi
          done

          # Convert arrays to JSON
          if [ ${#NEW_PACKAGES[@]} -eq 0 ]; then
            echo "packages=[]" >> $GITHUB_OUTPUT
            echo "has-new=false" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ All packages already have releases - nothing to build!"
          else
            PACKAGES_JSON=$(printf '%s\n' "${NEW_PACKAGES[@]}" | jq -R -s -c 'split("\n")[:-1]')
            echo "packages=$PACKAGES_JSON" >> $GITHUB_OUTPUT
            echo "has-new=true" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Packages to build: ${NEW_PACKAGES[@]}"
          fi

          if [ ${#SKIPPED_EXISTING[@]} -gt 0 ]; then
            SKIPPED_JSON=$(printf '%s\n' "${SKIPPED_EXISTING[@]}" | jq -R -s -c 'split("\n")[:-1]')
            echo "skipped-existing=$SKIPPED_JSON" >> $GITHUB_OUTPUT
            echo "â­ï¸  Skipped (already released): ${SKIPPED_EXISTING[@]}"
          else
            echo "skipped-existing=[]" >> $GITHUB_OUTPUT
          fi

  build:
    name: Build Packages
    needs: [detect-changes, filter-existing]
    if: needs.filter-existing.outputs.has-new == 'true'
    runs-on: ubuntu-latest
    continue-on-error: true  # Allow partial build failures
    strategy:
      fail-fast: false
      matrix:
        arch: [x86_64, aarch64, armv7, armhf]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Alpine Build Environment
        uses: ./.github/actions/setup-alpine-build
        with:
          arch: ${{ matrix.arch }}
          alpine-version: ${{ github.ref == 'refs/heads/main' && 'edge' || github.ref_name }}
          rsa-private-key: ${{ secrets.RSA_PRIVATE_KEY }}
          rsa-public-key: ${{ secrets.RSA_PUBLIC_KEY }}

      - name: Build packages for ${{ matrix.arch }}
        shell: alpine.sh {0}
        continue-on-error: true
        run: |
          PACKAGES='${{ needs.filter-existing.outputs.packages }}'
          BUILD_FAILED=0
          FAILED_PACKAGES=""
          SUCCESSFUL_PACKAGES=""
          SKIPPED_PACKAGES=""
          SKIPPED_EXISTING='${{ needs.filter-existing.outputs.skipped-existing }}'

          # Find the actual repository path
          REPO_PATH="${GITHUB_WORKSPACE:-/home/runner/work/aports/aports}"
          WORKSPACE="${GITHUB_WORKSPACE:-/home/runner/work/aports/aports}"
          cd "$REPO_PATH" || exit 1
          echo "Repository path: $REPO_PATH"
          echo "Current directory: $(pwd)"
          ls -la

          echo "Building packages for arch: ${{ matrix.arch }}"
          echo "Packages to build: $PACKAGES"

          # Parse JSON array
          for pkg_dir in $(echo "$PACKAGES" | jq -r '.[]'); do
            if [ -z "$pkg_dir" ]; then
              continue
            fi

            if [ ! -f "$pkg_dir/APKBUILD" ]; then
              echo "SKIP: $pkg_dir - no APKBUILD found"
              continue
            fi

            echo "========================================="
            echo "Building: $pkg_dir"
            echo "========================================="

            cd "$pkg_dir" || exit 1

            # Get package info
            . ./APKBUILD

            echo "Package: $pkgname (v$pkgver-r$pkgrel)"
            echo "Architecture: ${{ matrix.arch }}"
            echo "Architectures: $arch"

            # Check if this package should be built for this architecture
            if echo "$arch" | grep -qE "(all|noarch|${{ matrix.arch }})"; then
              if abuild -r 2>&1; then
                echo "âœ… SUCCESS: Built $pkgname"
                SUCCESSFUL_PACKAGES="$SUCCESSFUL_PACKAGES $pkgname"
              else
                echo "âŒ FAILED: Could not build $pkgname"
                BUILD_FAILED=1
                FAILED_PACKAGES="$FAILED_PACKAGES $pkgname"
              fi
            else
              echo "â­ï¸  SKIP: $pkgname not configured for ${{ matrix.arch }} (supports: $arch)"
              SKIPPED_PACKAGES="$SKIPPED_PACKAGES $pkgname"
            fi

            cd "$REPO_PATH" || exit 1
          done

          # Generate build summary
          echo ""
          echo "========================================="
          echo "Build Summary for ${{ matrix.arch }}"
          echo "========================================="
          if [ -n "$SUCCESSFUL_PACKAGES" ]; then
            echo "âœ… Successful: $SUCCESSFUL_PACKAGES"
          fi
          if [ -n "$FAILED_PACKAGES" ]; then
            echo "âŒ Failed: $FAILED_PACKAGES"
          fi
          if [ -n "$SKIPPED_PACKAGES" ]; then
            echo "â­ï¸  Skipped (arch not supported): $SKIPPED_PACKAGES"
          fi
          if [ -n "$SKIPPED_EXISTING" ] && [ "$SKIPPED_EXISTING" != "[]" ]; then
            EXISTING_LIST=$(echo "$SKIPPED_EXISTING" | jq -r '.[]' | tr '\n' ' ')
            echo "ðŸ“¦ Skipped (already released): $EXISTING_LIST"
          fi
          echo "========================================="

          # Save build status to file for later steps
          mkdir -p "$WORKSPACE/build-status"
          cat > "$WORKSPACE/build-status/${{ matrix.arch }}.txt" << EOF
          ARCH="${{ matrix.arch }}"
          ALPINE_VERSION="${{ github.ref == 'refs/heads/main' && 'edge' || github.ref_name }}"
          SUCCESSFUL="$SUCCESSFUL_PACKAGES"
          FAILED="$FAILED_PACKAGES"
          SKIPPED="$SKIPPED_PACKAGES"
          SKIPPED_EXISTING="$SKIPPED_EXISTING"
          EOF

          if [ $BUILD_FAILED -ne 0 ]; then
            echo "::warning::Build failed for: $FAILED_PACKAGES"
            exit 1
          fi

      - name: Sign packages
        shell: alpine.sh {0}
        continue-on-error: true
        run: |
          # Find and sign any unsigned packages
          find ~/packages -name "*.apk" -type f 2>/dev/null | while read -r pkg; do
            echo "Signing: $pkg"
            abuild-sign -k ~/.abuild/jambox-65ea124a.rsa "$pkg" 2>/dev/null || true
          done

      - name: Collect built packages
        shell: alpine.sh {0}
        run: |
          # Copy packages to a location accessible outside chroot
          WORKSPACE="${GITHUB_WORKSPACE:-/home/runner/work/aports/aports}"
          mkdir -p "$WORKSPACE/packages/${{ matrix.arch }}"
          find ~/packages -name "*.apk" -type f -exec cp {} "$WORKSPACE/packages/${{ matrix.arch }}/" \; 2>/dev/null || true
          ls -la "$WORKSPACE/packages/${{ matrix.arch }}/" || echo "No packages built"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: packages-${{ matrix.arch }}
          path: packages/${{ matrix.arch }}/
          retention-days: 30

      - name: Upload build status
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: build-status-${{ matrix.arch }}
          path: build-status/
          retention-days: 7

  build-summary:
    name: Build Summary Report
    needs: build
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Download all build status
        uses: actions/download-artifact@v4
        with:
          pattern: build-status-*
          path: build-status

      - name: Generate summary report
        run: |
          echo "# Build Summary for Alpine ${{ github.ref == 'refs/heads/main' && 'edge' || github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Branch: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          TOTAL_SUCCESS=0
          TOTAL_FAILED=0

          for status_dir in build-status/build-status-*/; do
            if [ ! -d "$status_dir" ]; then
              continue
            fi

            for status_file in "$status_dir"*.txt; do
              if [ ! -f "$status_file" ]; then
                continue
              fi

              . "$status_file"

              echo "## Architecture: $ARCH" >> $GITHUB_STEP_SUMMARY

              if [ -n "$SUCCESSFUL" ]; then
                echo "âœ… **Successful:**$SUCCESSFUL" >> $GITHUB_STEP_SUMMARY
                TOTAL_SUCCESS=$((TOTAL_SUCCESS + $(echo $SUCCESSFUL | wc -w)))
              fi

              if [ -n "$FAILED" ]; then
                echo "âŒ **Failed:**$FAILED" >> $GITHUB_STEP_SUMMARY
                TOTAL_FAILED=$((TOTAL_FAILED + $(echo $FAILED | wc -w)))
              fi

              if [ -n "$SKIPPED" ]; then
                echo "â­ï¸  **Skipped (not for this arch):**$SKIPPED" >> $GITHUB_STEP_SUMMARY
              fi

              if [ -n "$SKIPPED_EXISTING" ] && [ "$SKIPPED_EXISTING" != "[]" ]; then
                EXISTING_LIST=$(echo "$SKIPPED_EXISTING" | jq -r '.[]' | tr '\n' ' ')
                echo "ðŸ“¦ **Skipped (already released):**$EXISTING_LIST" >> $GITHUB_STEP_SUMMARY
              fi

              echo "" >> $GITHUB_STEP_SUMMARY
            done
          done

          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "**Total:** $TOTAL_SUCCESS succeeded, $TOTAL_FAILED failed" >> $GITHUB_STEP_SUMMARY

  create-release:
    name: Create GitHub Releases
    needs: [detect-changes, filter-existing, build]
    if: needs.filter-existing.outputs.has-new == 'true' && !cancelled()
    uses: ./.github/workflows/create-releases.yml
    permissions:
      contents: write
    secrets: inherit
    with:
      alpine-version: ${{ github.ref == 'refs/heads/main' && 'edge' || github.ref_name }}

  sign-and-publish:
    name: Sign and Publish Alpine Repository
    needs: [detect-changes, filter-existing, build]
    if: needs.filter-existing.outputs.has-new == 'true' && !cancelled()
    uses: ./.github/workflows/sign-and-publish.yml
    permissions:
      contents: write
      pages: write
    secrets: inherit
    with:
      alpine-version: ${{ github.ref == 'refs/heads/main' && 'edge' || github.ref_name }}
