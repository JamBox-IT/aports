name: Build Alpine Packages

# This workflow builds Alpine packages whenever an APKBUILD file is changed
# It supports multi-architecture builds and creates releases with the built packages

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'JamBox/*/APKBUILD'
      - 'testing/*/APKBUILD'
      - '.github/workflows/build-packages.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - 'JamBox/*/APKBUILD'
      - 'testing/*/APKBUILD'

# Allow manual triggering of builds
  workflow_dispatch:
    inputs:
      package_path:
        description: 'Specific package to build (e.g., JamBox/py3-mppsolar)'
        required: false
        type: string
      architectures:
        description: 'Architectures to build (comma-separated: x86_64,aarch64,armv7,armhf)'
        required: false
        default: 'x86_64,aarch64,armv7'
        type: string

permissions:
  contents: write
  packages: write
  pull-requests: write

jobs:
  # Job 1: Detect which packages have changed
  detect-changes:
    name: Detect Changed Packages
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.detect.outputs.packages }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history to detect changes

      - name: Detect changed packages
        id: detect
        run: |
          # Get list of changed files
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          else
            # For push events, compare with previous commit
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"
          fi

          # Handle workflow_dispatch (manual trigger)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.package_path }}" ]; then
            echo "Manual build triggered for: ${{ github.event.inputs.package_path }}"
            PACKAGES='["${{ github.event.inputs.package_path }}"]'
            echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get changed APKBUILD files
          echo "Comparing $BASE_SHA..$HEAD_SHA"
          CHANGED_FILES=$(git diff --name-only $BASE_SHA..$HEAD_SHA | grep -E '(JamBox|testing)/.*/APKBUILD$' || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No APKBUILD files changed"
            echo "packages=[]" >> $GITHUB_OUTPUT
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract package directories
          PACKAGES=$(echo "$CHANGED_FILES" | while read file; do
            # Extract directory path (e.g., "JamBox/py3-mppsolar" from "JamBox/py3-mppsolar/APKBUILD")
            dirname "$file"
          done | jq -R -s -c 'split("\n") | map(select(length > 0))')

          echo "Changed packages: $PACKAGES"
          echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
          echo "has_changes=true" >> $GITHUB_OUTPUT

  # Job 2: Build packages for each architecture
  build:
    name: Build ${{ matrix.package }} (${{ matrix.arch }})
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # Continue building other packages even if one fails
      matrix:
        package: ${{ fromJson(needs.detect-changes.outputs.packages) }}
        arch:
          - x86_64
          - aarch64
          - armv7
          - armhf

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU for multi-arch builds
        uses: docker/setup-qemu-action@v3
        with:
          platforms: all

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract package information
        id: pkg_info
        run: |
          PKG_DIR="${{ matrix.package }}"
          PKG_NAME=$(basename "$PKG_DIR")
          REPO_NAME=$(dirname "$PKG_DIR")

          # Read package version from APKBUILD
          cd "$PKG_DIR"

          # Extract pkgver and pkgrel from APKBUILD
          PKGVER=$(grep '^pkgver=' APKBUILD | cut -d'=' -f2 | tr -d '"')
          PKGREL=$(grep '^pkgrel=' APKBUILD | cut -d'=' -f2 | tr -d '"')
          VERSION="${PKGVER}-r${PKGREL}"

          echo "pkg_name=$PKG_NAME" >> $GITHUB_OUTPUT
          echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "pkg_dir=$PKG_DIR" >> $GITHUB_OUTPUT

          echo "Building $PKG_NAME version $VERSION for ${{ matrix.arch }}"

      - name: Build package using dabuild
        env:
          DABUILD_ARCH: ${{ matrix.arch }}
          DABUILD_VERSION: edge
          DABUILD_PACKAGES: /tmp/packages
        run: |
          # Clone or update docker-abuild if not present
          if [ ! -d "../docker-abuild" ]; then
            cd ..
            git clone https://github.com/alpinelinux/docker-abuild.git
            cd docker-abuild
            make dabuild
            cd ../aports
          fi

          # Create output directory
          mkdir -p /tmp/packages

          # Build the package
          cd "${{ steps.pkg_info.outputs.pkg_dir }}"

          echo "Building ${{ steps.pkg_info.outputs.pkg_name }} for ${{ matrix.arch }}..."

          # Run dabuild with the configured architecture
          DABUILD_ARCH=${{ matrix.arch }} \
          DABUILD_VERSION=edge \
          DABUILD_PACKAGES=/tmp/packages \
          ../../../docker-abuild/dabuild -r

      - name: Verify package was built
        run: |
          PKG_NAME="${{ steps.pkg_info.outputs.pkg_name }}"
          VERSION="${{ steps.pkg_info.outputs.version }}"
          ARCH="${{ matrix.arch }}"

          # Look for the built package
          BUILT_PKG=$(find /tmp/packages -name "${PKG_NAME}-${VERSION}.apk" -o -name "${PKG_NAME}_${VERSION}_${ARCH}.apk" | head -1)

          if [ -z "$BUILT_PKG" ]; then
            echo "ERROR: Package not found!"
            echo "Expected: ${PKG_NAME}-${VERSION}.apk"
            echo "Contents of /tmp/packages:"
            find /tmp/packages -type f
            exit 1
          fi

          echo "Built package: $BUILT_PKG"
          ls -lh "$BUILT_PKG"

      - name: Upload package artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.pkg_info.outputs.pkg_name }}-${{ steps.pkg_info.outputs.version }}-${{ matrix.arch }}
          path: /tmp/packages/**/*.apk
          retention-days: 30
          if-no-files-found: error

      - name: Generate package metadata
        run: |
          PKG_NAME="${{ steps.pkg_info.outputs.pkg_name }}"
          VERSION="${{ steps.pkg_info.outputs.version }}"
          ARCH="${{ matrix.arch }}"

          # Create metadata file
          cat > /tmp/package-metadata.json << EOF
          {
            "package": "$PKG_NAME",
            "version": "$VERSION",
            "architecture": "$ARCH",
            "repository": "${{ steps.pkg_info.outputs.repo_name }}",
            "build_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}"
          }
          EOF

          cat /tmp/package-metadata.json

      - name: Upload metadata
        uses: actions/upload-artifact@v4
        with:
          name: metadata-${{ steps.pkg_info.outputs.pkg_name }}-${{ matrix.arch }}
          path: /tmp/package-metadata.json
          retention-days: 30

  # Job 3: Create GitHub Release with built packages
  release:
    name: Create Release
    needs: [detect-changes, build]
    if: |
      needs.detect-changes.outputs.has_changes == 'true' &&
      github.event_name == 'push' &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all package artifacts
        uses: actions/download-artifact@v4
        with:
          path: packages/

      - name: Organize packages
        run: |
          mkdir -p release/

          # Move all .apk files to release directory
          find packages/ -name "*.apk" -exec cp {} release/ \;

          echo "Packages to release:"
          ls -lh release/

      - name: Generate release notes
        id: release_notes
        run: |
          PACKAGES="${{ needs.detect-changes.outputs.packages }}"

          # Create release notes
          cat > release_notes.md << 'EOF'
          ## Alpine Packages Built

          This release includes the following packages:

          EOF

          # List packages
          echo "$PACKAGES" | jq -r '.[]' | while read pkg; do
            PKG_NAME=$(basename "$pkg")
            echo "- **$PKG_NAME**" >> release_notes.md

            # Try to extract version from APKBUILD
            if [ -f "$pkg/APKBUILD" ]; then
              PKGVER=$(grep '^pkgver=' "$pkg/APKBUILD" | cut -d'=' -f2 | tr -d '"')
              PKGREL=$(grep '^pkgrel=' "$pkg/APKBUILD" | cut -d'=' -f2 | tr -d '"')
              echo "  - Version: $PKGVER-r$PKGREL" >> release_notes.md
            fi
          done

          cat >> release_notes.md << 'EOF'

          ### Architectures
          - x86_64
          - aarch64
          - armv7
          - armhf

          ### Installation

          Download the appropriate package for your architecture and install with:
          ```bash
          apk add --allow-untrusted <package-name>.apk
          ```

          Or add to your Alpine repository configuration.
          EOF

          cat release_notes.md

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: build-${{ github.run_number }}-${{ github.sha }}
          name: Package Build ${{ github.run_number }}
          body_path: release_notes.md
          files: release/*.apk
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 4: Build summary
  summary:
    name: Build Summary
    needs: [detect-changes, build]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Generate summary
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.detect-changes.outputs.has_changes }}" != "true" ]; then
            echo "✅ No package changes detected - no builds required" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          echo "### Packages Built" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ needs.detect-changes.outputs.packages }}" | jq -r '.[]' | while read pkg; do
            echo "- $pkg" >> $GITHUB_STEP_SUMMARY
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Build Status" >> $GITHUB_STEP_SUMMARY
          echo "- Total jobs: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.build.result }}" = "success" ]; then
            echo "✅ All builds completed successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ Some builds may have failed - check job details" >> $GITHUB_STEP_SUMMARY
          fi
